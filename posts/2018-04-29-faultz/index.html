<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-49279373-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-49279373-1")</script><title>AstromechZA - Ben Meier</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The HTML5 Herald"><meta name=author content="Ben Meier"><link href=https://github.com/astromechza rel=me><link href=https://hachyderm.io/@benmeier_ rel=me><meta name=generator content="Hugo 0.110.0"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=https://astromechza.github.io/css/styles.css></head><body><div id=container><header><h1><a href=https://astromechza.github.io/>AstromechZA - Ben Meier</a></h1><ul id=social-media class=fa-ul><li><a href=https://hachyderm.io/@benmeier_><i class="fab fa-mastodon fa-fw"></i></a></li><li><a href=https://twitter.com/@benmeier_><i class="fab fa-twitter fa-fw"></i></a></li><li><a href=https://github.com/AstromechZA><i class="fab fa-github fa-fw"></i></a></li></ul><p><em>My Mind on Code</em></p></header><nav><ul><li><a class=active href=https://astromechza.github.io/posts/><i class="fa-li fa fa-lg"></i><span>All Posts</span></a></li></ul></nav><main><article><h1>Thoughts on a fault injection API</h1><aside><ul><li><time class=post-date datetime=2018-04-29T21:23:26+01:00>Apr 29, 2018</time></li><li><em><a href=https://astromechza.github.io/tags/chaos-engineering/>#Chaos Engineering</a></em></li><li>4 min read</li></ul></aside><p>Managed fault injection APIs for providing powerful chaos engineering functionality. How about a <code>POST /faultz</code> endpoint for in-process chaos engineering?</p><p>I recently re-watched Kelsey Hightower’s <a href=https://vimeo.com/173610242>&ldquo;Monitoring from the inside&rdquo;</a> (2016) talk regarding leveraging healthcheck endpoints for readiness monitoring of services in a Kubernetes context and it set some seeds going in my mind. I’ve been using <code>/healthcheck</code> or <code>/healthz</code> endpoints for a while now, using them to debug issues or just view service specific facts while a service runs. In the same team, we’ve also been making a push towards various deep integration tests to increase code coverage inside various asynchronous workflows during CI/CD periods. One of the things we needed was a way to trigger failures in these workflows <strong>on purpose</strong>. <em>We’d rather the workflow ended gracefully with an explicit failure message rather than causing uncontrolled failure of other unrelated systems or workflows.</em></p><p>This is harder than you want it to be, as you’re fighting against the flow of other devs fixing the very classes or issues you’re trying to trigger!</p><p>Part of this is just picking the faults correctly, there’s no point trying to trigger &ldquo;fixable&rdquo; issues. A syntax bug will be fixed shortly, while a complex behaviour in network-partition scenarios would be a better use of your time to test and is something that is likely to happen due to more uncontrollable issues like hardware failure, denial-of-service, resource starvation, etc.</p><p>Our first and minimal version of this is to include hidden and feature flagged options in a workflow which can sit dormant until a specific point in the workflow in which it can be triggered.</p><p>An equivalent of:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> fault_injection_is_enabled <span style=color:#f92672>and</span> workflow<span style=color:#f92672>.</span>_stage_N_fault:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>()
</span></span></code></pre></div><p>This worked, as we could run failure tests as part of our CI tests and we could ensure that we didn’t have a regression in the behaviour of such a failure. But it always felt fairly messy and having “hidden” bits of your API is just one step closer to a backdoor.</p><p><strong>However</strong>, I’d like to investigate taking this a bit further.</p><p>In many existing “Chaos Engineering” techniques, most injected failures are at the OS level:</p><ul><li>iptables can cause network partitions</li><li>bash scripts can be used to consume resources, fire requests against things</li><li>etc..</li></ul><p>What about having service owners commit to providing some service-level fault capabilities?</p><p>Note: these are just brain-farts, and don’t include serious thought regarding authorization, limitations, deadman-switches, etc..</p><h3 id=example-1-trigger-a-panic-in-the-incoming-requests-context>Example 1: Trigger a panic in the incoming request’s context</h3><p>Pretty brute force and in-elegant, but why not? Rather than attempting to ensure that the service will never panic (100% coverage?), why not ensure that if it does panic, it won’t affect the larger system other than maybe a 500 response. (You could also recover from it, but that’s not the point here)</p><pre tabindex=0><code>POST /faultz/trigger/panic
</code></pre><p>Expected results: process dies, socket closes, LB doesn’t send any more traffic to it, HA kicks in and launches it somewhere else, etc..</p><p>This is pretty similar to a Chaos or QA team just kill-9&rsquo;ing your process.</p><h3 id=example-2-slow-down-the-next-n-incoming-requests-by-a-random-interval-in-0-m>Example 2: Slow down the next N incoming requests by a random interval in 0-M</h3><p>Attempt to simulate load on the system causing requests to be processed more slowly. This would need to be bolted in at a higher level in front of your http handlers so that it could be generalised nicely between them. It would also be wise to be able to cancel this behaviour in case you’re testing in prod.</p><pre tabindex=0><code>POST /faultz/start/slow-period/00001
api: /my/target/path 
remaining_count: 150
delay_ms_min: 0
delay_ms_max: 60000
expire_at: 2018-01-01T05:56:57 
</code></pre><p>Now hopefully you’ll see the next 150 requests to <code>/my/target/path</code> take longer than expected, but this behaviour will end after either 150 requests, or 60 seconds.</p><h3 id=example-3-decrease-size-of-the-apps-connection-pool-dynamically>Example 3: decrease size of the apps connection pool dynamically</h3><p>This could be done by just loading it with more requests, but perhaps it could be achieved internally as well by decreasing the number of requests the service will handle?</p><p>This could also be achieved by example 2.</p><h3 id=example-4-queue-up-a-failure-for-the-next-time-a-particular-code-point-it-hit-when-certain-parameters-are-matched>Example 4: queue up a failure for the next time a particular code-point it hit when certain parameters are matched</h3><pre tabindex=0><code>POST /faultz/prepare/database-get-failure/0001
model: User
failure: http-500
expire_at: 2018-01-01T05:56:57
requirements:
  - username: BillGates
</code></pre><p>This kind of equivalent to my previous example of fault injection in a team of mine.</p><h3 id=example-5-gradually-consume-more-and-more-ram-over-the-next-n-seconds>Example 5: gradually consume more and more RAM over the next N seconds</h3><pre tabindex=0><code>POST /faultz/start/ram-consumer/0001
target: 1GB
allocation_randomness: 0.7
expire_at: 2018-01-01T05:56:57
</code></pre><p>This may just begin allocating a large linked list of arrays of random int64’s at a fairly controlled-or-variable rate. Perhaps we expect to see alarms go off, GC to increase, or other failures.</p><h3 id=example-5-allow-the-faultz-api-to-be-self-documenting>Example 5: allow the faultz api to be self documenting</h3><p>Perhaps <code>GET /faultz/help</code> can list the available failure API endpoints in a swagger-ish form?</p><p>Unsure if this is such a good idea :) but could be interesting for teams that want to own some of their own chaos engineering or fault injection.</p></article><section class=post-nav><ul><li><a href=https://astromechza.github.io/posts/2018-04-28-perkeep/><i class="fa fa-chevron-circle-left"></i> Messing around with Perkeep (part 1)</a></li><li><a href=https://astromechza.github.io/posts/2018-06-29-ipvs/>A Minimal IPVS Load Balancer demo <i class="fa fa-chevron-circle-right"></i></a></li></ul></section></main><footer><h6>Copyright © 2018 - Ben Meier |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=https://astromechza.github.io/index.xml>Subscribe</a></h6></footer></div><script src=https://astromechza.github.io/js/scripts.js></script></body></html>